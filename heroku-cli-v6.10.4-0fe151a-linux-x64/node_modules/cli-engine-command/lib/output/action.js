'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shouldDisplaySpinner = shouldDisplaySpinner;
function shouldDisplaySpinner(out) {
  return !out.mock && !out.config.debug && !!process.stdin.isTTY && !!process.stderr.isTTY && !process.env.CI && process.env.TERM !== 'dumb';
}

class ActionBase {

  start(action, status) {
    const task = this.task = { action, status, active: this.task && this.task.active };
    this._start();
    task.active = true;
  }

  stop(msg = 'done') {
    const task = this.task;
    if (!task) return;
    this.status = msg;
    this._stop();
    task.active = false;
    delete this.task;
  }

  get status() {
    return this.task ? this.task.status : undefined;
  }
  set status(status) {
    const task = this.task;
    if (!task) return;
    if (task.status === status) return;
    this._updateStatus(status, task.status);
    task.status = status;
  }

  pause(fn, icon) {
    const task = this.task;
    const active = task && task.active;
    if (task && active) {
      this._pause(icon);
      task.active = false;
    }
    let ret = fn();
    if (task && active) {
      this._resume();
    }
    return ret;
  }

  _start() {
    throw new Error('not implemented');
  }
  _stop() {
    throw new Error('not implemented');
  }
  _resume() {
    if (this.task) this.start(this.task.action, this.task.status);
  }
  _pause(icon) {
    throw new Error('not implemented');
  }
  _updateStatus(status, prevStatus) {}
}

exports.ActionBase = ActionBase;
class SimpleAction extends ActionBase {

  constructor(out) {
    super();
    this.out = out;
  }

  _start() {
    const task = this.task;
    if (!task) return;
    this._render(task.action, task.status);
  }

  _pause(icon) {
    if (icon) this._updateStatus(icon);
    this._write('\n');
  }

  _resume() {}

  _updateStatus(status, prevStatus) {
    const task = this.task;
    if (!task) return;
    if (task.active && !prevStatus) this._write(` ${status}`);else this._render(task.action, status);
  }

  _stop() {
    this._write('\n');
  }

  _render(action, status) {
    const task = this.task;
    if (!task) return;
    if (task.active) this._write('\n');
    this._write(status ? `${action}... ${status}` : `${action}...`);
  }

  _write(s) {
    this.out.stderr.write(s);
  }
}

exports.SimpleAction = SimpleAction;
class SpinnerAction extends ActionBase {

  constructor(out) {
    super();
    this.out = out;
    this.ansi = require('ansi-escapes');
    this.frames = require('./spinners.js')[process.platform === 'win32' ? 'line' : 'dots2'].frames;
    this.frameIndex = 0;
    const screen = require('./screen');
    this.width = screen.errtermwidth;
  }

  _start() {
    this._reset();
    if (this.spinner) clearInterval(this.spinner);
    this._render();
    let interval = this.spinner = setInterval(this._render.bind(this), 100, 'spinner');
    interval.unref();
  }

  _stop() {
    clearInterval(this.spinner);
    this._render();
    this.output = null;
  }

  _pause(icon) {
    clearInterval(this.spinner);
    this._reset();
    if (icon) this._render(` ${icon}`);
    this.output = null;
  }

  _render(icon) {
    const task = this.task;
    if (!task) return;
    this._reset();
    let frame = icon === 'spinner' ? ` ${this._frame()}` : icon || '';
    let status = task.status ? ` ${task.status}` : '';
    this.output = `${task.action}...${frame}${status}\n`;
    this._write(this.output);
  }

  _reset() {
    if (!this.output) return;
    let lines = this._lines(this.output);
    this._write(this.ansi.cursorLeft + this.ansi.cursorUp(lines) + this.ansi.eraseDown);
    this.output = null;
  }

  _frame() {
    let frame = this.frames[this.frameIndex];
    this.frameIndex = ++this.frameIndex % this.frames.length;
    return this.out.color.heroku(frame);
  }

  _lines(s) {
    return this.out.color.stripColor(s).split('\n').map(l => Math.ceil(l.length / this.width)).reduce((c, i) => c + i, 0);
  }

  _write(s) {
    this.out.stderr.write(s);
  }
}
exports.SpinnerAction = SpinnerAction;