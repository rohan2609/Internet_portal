'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

require('cli-engine-config');

var _cliEngineCommand = require('cli-engine-command');

var _cliEngineCommand2 = _interopRequireDefault(_cliEngineCommand);

var _plugin = require('./plugin');

var _plugin2 = _interopRequireDefault(_plugin);

var _linked = require('./linked');

var _linked2 = _interopRequireDefault(_linked);

var _user = require('./user');

var _user2 = _interopRequireDefault(_user);

var _builtin = require('./builtin');

var _builtin2 = _interopRequireDefault(_builtin);

var _core = require('./core');

var _core2 = _interopRequireDefault(_core);

var _lodash = require('lodash.uniqby');

var _lodash2 = _interopRequireDefault(_lodash);

var _cache = require('./cache');

var _cache2 = _interopRequireDefault(_cache);

var _namespaces = require('../namespaces');

var _namespaces2 = _interopRequireDefault(_namespaces);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Plugins {
  constructor(output) {
    this.out = output;
    this.config = output.config;
    this.cache = new _cache2.default(output);

    this.builtin = new _builtin2.default(this);
    this.linked = new _linked2.default(this);
    this.user = new _user2.default(this);
    this.core = new _core2.default(this);

    this.plugins = this.cache.fetchManagers(this.builtin, this.linked, this.user, this.core);
  }

  get commands() {
    let commands = [];
    for (let plugin of this.plugins) {
      try {
        commands = commands.concat(plugin.commands);
      } catch (err) {
        this.out.warn(err, `error reading plugin ${plugin.name}`);
      }
    }
    return commands;
  }

  list() {
    return this.plugins;
  }

  isPluginInstalled(name) {
    return !!this.plugins.find(p => p.name === name);
  }

  findCommand(cmd) {
    for (let plugin of this.plugins) {
      let c = plugin.findCommand(cmd);
      if (c) return c;
    }
  }

  commandsForTopic(topic) {
    let commands = this.plugins.reduce((t, p) => {
      try {
        return t.concat(p.commands.filter(c => c.topic === topic).map(c => p.findCommand(c.id)));
      } catch (err) {
        this.out.warn(err, `error reading plugin ${p.name}`);
        return t;
      }
    }, []);
    return (0, _lodash2.default)(commands, 'id');
  }

  findTopic(cmd) {
    if (!cmd) return;
    for (let plugin of this.plugins) {
      let t = plugin.findTopic(cmd);
      if (t) return t;
    }
    let name = cmd.split(':').slice(0, cmd.split(':').length - 1).join(':');
    return this.findTopic(name);
  }

  findNamespaced(namespace) {
    return this.plugins.filter(p => p.namespace === namespace);
  }

  async install(name, tag = 'latest') {
    if (this.plugins.find(p => p.name === name && p.tag === tag)) throw new Error(`Plugin ${name} is already installed`);
    let path = await this.user.install(name, tag);
    this.clearCache(path);
  }

  async update() {
    if (this.user.list().length === 0) return;
    this.out.action.start(`${this.config.name}: Updating plugins`);
    await this.user.update();
    this.clearCache(...this.user.list().map(p => p.path));
  }

  async uninstall(name) {
    let plugin = this.plugins.filter(p => ['user', 'link'].includes(p.type)).find(p => p.name === name);
    if (!plugin) throw new Error(`${name} is not installed`);
    switch (plugin.type) {
      case 'user':
        {
          if (!this.config.debug) this.out.action.start(`Uninstalling plugin ${name}`);
          await this.user.remove(name);
          break;
        }
      case 'link':
        {
          if (!this.config.debug) this.out.action.start(`Unlinking plugin ${name}`);
          this.linked.remove(plugin.path);
          break;
        }
    }
    this.clearCache(plugin.path);
    this.out.action.stop();
  }

  addPackageToPJSON(name, version = '*') {
    this.user.addPackageToPJSON(name, version);
  }

  async addLinkedPlugin(p) {
    let name = this.linked.checkLinked(p);
    if (this.plugins.find(p => p.type === 'user' && p.name === name)) {
      throw new Error(`${name} is already installed.\nUninstall with ${this.out.color.cmd(this.config.bin + ' plugins:uninstall ' + name)}`);
    }
    if (!_namespaces2.default.namespacePermitted(p, this.config)) throw _namespaces2.default.notPermittedError;

    await this.linked.add(p);
    this.clearCache(p);
  }

  async refreshLinkedPlugins() {
    let paths = await this.linked.refresh();
    this.clearCache(...paths);
  }

  clearCache(...paths) {
    this.cache.deletePlugin(...paths);
  }

  get topics() {
    return (0, _lodash2.default)(this.plugins.reduce((t, p) => t.concat(p.topics), []), 'topic');
  }

}
exports.default = Plugins;